#!/bin/bash
# Production deployment script for VPS or cloud infrastructure
# This script sets up the production environment and deploys the application

set -e

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"
ENVIRONMENT="${ENVIRONMENT:-production}"
DATA_PATH="${DATA_PATH:-/opt/app/data}"
BACKUP_PATH="${BACKUP_PATH:-/opt/app/backups}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if running as root or with sudo
check_permissions() {
    if [[ $EUID -ne 0 ]]; then
        log_error "This script must be run as root or with sudo"
        exit 1
    fi
}

# Install required system packages
install_dependencies() {
    log_info "Installing system dependencies..."
    
    # Update package lists
    apt-get update
    
    # Install Docker and Docker Compose
    if ! command -v docker &> /dev/null; then
        log_info "Installing Docker..."
        curl -fsSL https://get.docker.com -o get-docker.sh
        sh get-docker.sh
        rm get-docker.sh
        systemctl enable docker
        systemctl start docker
    fi
    
    if ! command -v docker-compose &> /dev/null; then
        log_info "Installing Docker Compose..."
        curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
        chmod +x /usr/local/bin/docker-compose
    fi
    
    # Install other utilities
    apt-get install -y \
        curl \
        wget \
        unzip \
        htop \
        logrotate \
        fail2ban \
        ufw \
        certbot \
        python3-certbot-nginx
}

# Setup firewall
setup_firewall() {
    log_info "Configuring firewall..."
    
    # Reset UFW to defaults
    ufw --force reset
    
    # Default policies
    ufw default deny incoming
    ufw default allow outgoing
    
    # Allow SSH (adjust port if needed)
    ufw allow 22/tcp
    
    # Allow HTTP and HTTPS
    ufw allow 80/tcp
    ufw allow 443/tcp
    
    # Enable firewall
    ufw --force enable
    
    log_info "Firewall configured successfully"
}

# Create application directories
setup_directories() {
    log_info "Setting up application directories..."
    
    # Create directories
    mkdir -p "$DATA_PATH"/{postgres,redis,postgres-backups,redis-backups}
    mkdir -p "$BACKUP_PATH"
    mkdir -p /opt/app/logs
    mkdir -p /opt/app/secrets
    
    # Set permissions
    chown -R 1001:1001 "$DATA_PATH"
    chmod -R 755 "$DATA_PATH"
    chmod 700 /opt/app/secrets
    
    log_info "Directories created successfully"
}

# Generate secrets
generate_secrets() {
    log_info "Generating application secrets..."
    
    local secrets_dir="/opt/app/secrets"
    
    # Generate random secrets if they don't exist
    [ ! -f "$secrets_dir/postgres_password.txt" ] && openssl rand -base64 32 > "$secrets_dir/postgres_password.txt"
    [ ! -f "$secrets_dir/backup_password.txt" ] && openssl rand -base64 32 > "$secrets_dir/backup_password.txt"
    [ ! -f "$secrets_dir/redis_password.txt" ] && openssl rand -base64 32 > "$secrets_dir/redis_password.txt"
    [ ! -f "$secrets_dir/session_signing_secret.txt" ] && openssl rand -base64 64 > "$secrets_dir/session_signing_secret.txt"
    [ ! -f "$secrets_dir/csrf_signing_secret.txt" ] && openssl rand -base64 64 > "$secrets_dir/csrf_signing_secret.txt"
    
    # Create placeholder files for OIDC secrets (to be filled manually)
    [ ! -f "$secrets_dir/oidc_google_client_secret.txt" ] && echo "CHANGE_ME" > "$secrets_dir/oidc_google_client_secret.txt"
    [ ! -f "$secrets_dir/oidc_microsoft_client_secret.txt" ] && echo "CHANGE_ME" > "$secrets_dir/oidc_microsoft_client_secret.txt"
    
    # Set secure permissions
    chmod 600 "$secrets_dir"/*.txt
    
    log_info "Secrets generated successfully"
    log_warn "Remember to update OIDC client secrets in $secrets_dir/"
}

# Setup SSL certificates
setup_ssl() {
    local domain="$1"
    local email="$2"
    
    if [[ -z "$domain" || -z "$email" ]]; then
        log_warn "Skipping SSL setup - domain or email not provided"
        log_warn "Run: certbot --nginx -d yourdomain.com -m your-email@example.com --agree-tos -n"
        return
    fi
    
    log_info "Setting up SSL certificates for $domain..."
    
    # Create nginx SSL directory
    mkdir -p "$PROJECT_DIR/docker/nginx/ssl"
    
    # Get certificate
    certbot certonly \
        --webroot \
        --webroot-path=/var/www/html \
        --email "$email" \
        --agree-tos \
        --no-eff-email \
        -d "$domain"
    
    # Copy certificates to nginx directory
    cp "/etc/letsencrypt/live/$domain/fullchain.pem" "$PROJECT_DIR/docker/nginx/ssl/"
    cp "/etc/letsencrypt/live/$domain/privkey.pem" "$PROJECT_DIR/docker/nginx/ssl/"
    
    # Setup auto-renewal
    echo "0 12 * * * /usr/bin/certbot renew --quiet" | crontab -
    
    log_info "SSL certificates configured successfully"
}

# Create environment file
create_env_file() {
    log_info "Creating production environment file..."
    
    local env_file="$PROJECT_DIR/.env.production"
    
    cat > "$env_file" << EOF
# Production Environment Configuration
ENVIRONMENT=production

# Infrastructure
DATABASE_URL=postgresql://appuser:\$(cat /opt/app/secrets/postgres_password.txt)@postgres:5432/appdb
REDIS_URL=redis://:\$(cat /opt/app/secrets/redis_password.txt)@redis:6379/0
TEMPORAL_URL=temporal:7233

# Application
BASE_URL=https://yourdomain.com
APP_PORT=8000
APP_REPLICAS=2
DATA_PATH=$DATA_PATH

# Database Configuration
POSTGRES_DB=appdb
POSTGRES_USER=appuser

# JWT Configuration
JWT_AUDIENCE=api://default
SESSION_MAX_AGE=3600

# CORS Configuration
CLIENT_ORIGIN=https://yourdomain.com

# OIDC Configuration (update these)
OIDC_GOOGLE_CLIENT_ID=your-google-client-id
OIDC_MICROSOFT_CLIENT_ID=your-microsoft-client-id

# Temporal Configuration
TEMPORAL_LOG_LEVEL=info
SKIP_TEMPORAL_SCHEMA_SETUP=false
EOF
    
    log_info "Environment file created at $env_file"
    log_warn "Remember to update the configuration values in $env_file"
}

# Deploy application
deploy_application() {
    log_info "Deploying application..."
    
    cd "$PROJECT_DIR"
    
    # Copy secrets to project directory for docker-compose
    cp -r /opt/app/secrets ./secrets
    
    # Build and start services
    docker-compose -f docker-compose.prod.yml --env-file .env.production build
    docker-compose -f docker-compose.prod.yml --env-file .env.production up -d
    
    # Cleanup secrets copy
    rm -rf ./secrets
    
    log_info "Application deployed successfully"
}

# Setup monitoring and logging
setup_monitoring() {
    log_info "Setting up monitoring and logging..."
    
    # Setup log rotation
    cat > /etc/logrotate.d/docker-app << EOF
/opt/app/logs/*.log {
    daily
    missingok
    rotate 30
    compress
    delaycompress
    notifempty
    sharedscripts
    postrotate
        docker-compose -f $PROJECT_DIR/docker-compose.prod.yml restart app
    endscript
}
EOF
    
    # Setup backup cron job
    cat > /etc/cron.d/app-backup << EOF
# Daily database backup at 2 AM
0 2 * * * root docker exec \$(docker ps -q -f name=postgres) /usr/local/bin/backup.sh
# Daily Redis backup at 2:30 AM
30 2 * * * root docker exec \$(docker ps -q -f name=redis) /usr/local/bin/backup.sh
EOF
    
    log_info "Monitoring and logging configured"
}

# Print deployment summary
print_summary() {
    log_info "Deployment completed successfully!"
    echo
    echo "Next steps:"
    echo "1. Update configuration in .env.production"
    echo "2. Update OIDC client secrets in /opt/app/secrets/"
    echo "3. Setup SSL certificates: certbot --nginx -d yourdomain.com"
    echo "4. Test the application: curl https://yourdomain.com/health"
    echo
    echo "Useful commands:"
    echo "- View logs: docker-compose -f docker-compose.prod.yml logs -f"
    echo "- Restart app: docker-compose -f docker-compose.prod.yml restart"
    echo "- Update app: docker-compose -f docker-compose.prod.yml pull && docker-compose -f docker-compose.prod.yml up -d"
}

# Main deployment function
main() {
    local domain="$1"
    local email="$2"
    
    log_info "Starting production deployment..."
    
    check_permissions
    install_dependencies
    setup_firewall
    setup_directories
    generate_secrets
    create_env_file
    
    if [[ -n "$domain" && -n "$email" ]]; then
        setup_ssl "$domain" "$email"
    fi
    
    deploy_application
    setup_monitoring
    print_summary
}

# Parse command line arguments
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    case "${1:-deploy}" in
        "deploy")
            main "$2" "$3"
            ;;
        "ssl")
            setup_ssl "$2" "$3"
            ;;
        "secrets")
            generate_secrets
            ;;
        "help")
            echo "Usage: $0 [deploy|ssl|secrets|help] [domain] [email]"
            echo "  deploy: Full deployment (default)"
            echo "  ssl: Setup SSL certificates only"
            echo "  secrets: Generate secrets only"
            echo "  help: Show this help"
            ;;
        *)
            echo "Unknown command: $1"
            echo "Use '$0 help' for usage information"
            exit 1
            ;;
    esac
fi