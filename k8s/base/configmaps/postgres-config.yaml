apiVersion: v1
kind: ConfigMap
metadata:
  name: postgres-config
  namespace: api-template-prod
  labels:
    app.kubernetes.io/name: postgres
    app.kubernetes.io/component: database
data:
  # PostgreSQL configuration file
  postgresql.conf: |
    # PostgreSQL Production Configuration
    # Optimized for production workloads with security hardening
    
    # Connection Settings
    listen_addresses = '*'
    port = 5432
    max_connections = 100
    superuser_reserved_connections = 3
    
    # Memory Settings (adjust based on available RAM)
    shared_buffers = 256MB
    work_mem = 4MB
    maintenance_work_mem = 64MB
    effective_cache_size = 1GB
    
    # Write Ahead Logging (WAL)
    wal_level = replica
    max_wal_size = 1GB
    min_wal_size = 80MB
    checkpoint_completion_target = 0.9
    wal_buffers = 16MB
    
    # Query Planning
    random_page_cost = 1.1
    effective_io_concurrency = 200
    
    # Security Settings
    ssl = on
    ssl_cert_file = '/etc/postgresql/ssl/server.crt'
    ssl_key_file = '/etc/postgresql/ssl/server.key'
    ssl_prefer_server_ciphers = on
    ssl_ciphers = 'HIGH:!aNULL:!MD5'
    ssl_min_protocol_version = 'TLSv1.2'
    ssl_max_protocol_version = 'TLSv1.3'
    password_encryption = scram-sha-256
    
    # Additional Security
    row_security = on
    log_statement = 'ddl'
    log_min_error_statement = error
    
    # Logging
    log_destination = 'stderr'
    logging_collector = on
    log_directory = 'pg_log'
    log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
    log_file_mode = 0640
    log_truncate_on_rotation = on
    log_rotation_age = 1d
    log_rotation_size = 100MB
    log_line_prefix = '%t [%p-%l] %q%u@%d '
    log_min_duration_statement = 1000
    log_checkpoints = on
    log_connections = on
    log_disconnections = on
    log_lock_waits = on
    log_temp_files = 0
    
    # Statement Tracking
    shared_preload_libraries = 'pg_stat_statements'
    track_activities = on
    track_counts = on
    track_io_timing = on
    track_functions = all
    
    # Autovacuum
    autovacuum = on
    autovacuum_naptime = 1min
    autovacuum_vacuum_threshold = 50
    autovacuum_analyze_threshold = 50
    
    # Data Integrity
    fsync = on
    synchronous_commit = on
    full_page_writes = on
    wal_log_hints = on
    
    # Locale and Formatting
    timezone = 'UTC'
    log_timezone = 'UTC'
    datestyle = 'iso, mdy'
    default_text_search_config = 'pg_catalog.english'

  # PostgreSQL host-based authentication configuration
  pg_hba.conf: |
    # TYPE  DATABASE        USER            ADDRESS                 METHOD
    
    # Unix socket: allow postgres via peer, others via SCRAM
    local   all             postgres                                peer
    local   all             all                                     scram-sha-256
    
    # Localhost (IPv4/IPv6)
    host    all             all             127.0.0.1/32            scram-sha-256
    host    all             all             ::1/128                 scram-sha-256
    
    # Replication from localhost only
    local   replication     all                                     peer
    host    replication     all             127.0.0.1/32            scram-sha-256
    host    replication     all             ::1/128                 scram-sha-256
    
    # --- Enforce TLS on networks ---
    
    # 1) Explicitly reject NON-TLS first (v4 + v6)
    hostnossl all           all             0.0.0.0/0               reject
    hostnossl all           all             ::/0                    reject
    
    # 2) Allow TLS from Kubernetes cluster network (adjust to your cluster CIDR)
    hostssl  all            all             10.0.0.0/8              scram-sha-256
    hostssl  all            all             172.16.0.0/12           scram-sha-256
    hostssl  all            all             192.168.0.0/16          scram-sha-256
    
    # 3) Final catch-alls (defense in depth)
    host     all            all             0.0.0.0/0               reject
    host     all            all             ::/0                    reject

  # Database initialization script
  01-init-app.sh: |
    #!/bin/sh
    set -eu
    
    # Required env (provided by deployment)
    : "${APP_DB:?missing APP_DB}"
    : "${APP_DB_OWNER:?missing APP_DB_OWNER}"
    : "${APP_DB_USER:?missing APP_DB_USER}"
    : "${APP_DB_RO_USER:?missing APP_DB_RO_USER}"
    : "${TEMPORAL_DB_USER:?missing TEMPORAL_DB_USER}"
    : "${POSTGRES_APP_USER_PW:?missing POSTGRES_APP_USER_PW}"
    : "${POSTGRES_APP_RO_PW:?missing POSTGRES_APP_RO_PW}"
    : "${POSTGRES_TEMPORAL_PW:?missing POSTGRES_TEMPORAL_PW}"
    
    # Optional override for Temporal owner (NOLOGIN). Default: "<temporal_user>_owner"
    TEMPORAL_DB_OWNER="${TEMPORAL_DB_OWNER:-${TEMPORAL_DB_USER}_owner}"
    
    # Database names (override if you like)
    TEMPORAL_DB="${TEMPORAL_DB:-temporal}"
    TEMPORAL_VIS_DB="${TEMPORAL_VIS_DB:-temporal_visibility}"
    
    APP_SCHEMA="${APP_SCHEMA:-app}"
    
    echo "==> Initializing roles/db for ${APP_DB} and Temporal"
    
    psql -v ON_ERROR_STOP=1 \
      -v APP_DB="${APP_DB}" \
      -v APP_OWNER_USER="${APP_DB_OWNER}" \
      -v APP_USER="${APP_DB_USER}" \
      -v APP_RO_USER="${APP_DB_RO_USER}" \
      -v APP_USER_PASSWORD="${POSTGRES_APP_USER_PW}" \
      -v APP_RO_USER_PASSWORD="${POSTGRES_APP_RO_PW}" \
      -v TEMPORAL_OWNER_USER="${TEMPORAL_DB_OWNER}" \
      -v TEMPORAL_USER="${TEMPORAL_DB_USER}" \
      -v TEMPORAL_USER_PASSWORD="${POSTGRES_TEMPORAL_PW}" \
      -v TEMPORAL_DB="${TEMPORAL_DB}" \
      -v TEMPORAL_VIS_DB="${TEMPORAL_VIS_DB}" \
      -v APP_SCHEMA="${APP_SCHEMA}" <<'PSQL'
    \set ON_ERROR_STOP on
    
    \echo === Creating roles and database for :'APP_DB' ===
    
    -- App: NOLOGIN owner (ownership container / default privileges anchor)
    SELECT format('CREATE ROLE %I NOLOGIN', :'APP_OWNER_USER')
    WHERE NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = :'APP_OWNER_USER')\gexec
    
    -- App: LOGIN users
    SELECT format('CREATE ROLE %I LOGIN PASSWORD %L', :'APP_USER', :'APP_USER_PASSWORD')
    WHERE NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = :'APP_USER')\gexec
    
    SELECT format('CREATE ROLE %I LOGIN PASSWORD %L', :'APP_RO_USER', :'APP_RO_USER_PASSWORD')
    WHERE NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = :'APP_RO_USER')\gexec
    
    -- App: database owned by NOLOGIN owner
    SELECT format('CREATE DATABASE %I OWNER %I', :'APP_DB', :'APP_OWNER_USER')
    WHERE NOT EXISTS (SELECT 1 FROM pg_database WHERE datname = :'APP_DB')\gexec
    
    \connect :APP_DB
    
    CREATE EXTENSION IF NOT EXISTS btree_gin;
    
    -- App: schema owned by NOLOGIN owner
    SELECT format('CREATE SCHEMA %I AUTHORIZATION %I', :'APP_SCHEMA', :'APP_OWNER_USER')
    WHERE NOT EXISTS (
      SELECT 1 FROM information_schema.schemata WHERE schema_name = :'APP_SCHEMA'
    )\gexec
    
    -- App: lock down
    SELECT format('REVOKE CREATE ON DATABASE %I FROM PUBLIC', :'APP_DB')\gexec
    SELECT format('REVOKE ALL ON SCHEMA %I FROM PUBLIC', :'APP_SCHEMA')\gexec
    
    -- App: runtime grants
    SELECT format('GRANT USAGE ON SCHEMA %I TO %I', :'APP_SCHEMA', :'APP_USER')\gexec
    SELECT format('GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA %I TO %I',
                  :'APP_SCHEMA', :'APP_USER')\gexec
    SELECT format('GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA %I TO %I',
                  :'APP_SCHEMA', :'APP_USER')\gexec
    
    SELECT format('GRANT USAGE ON SCHEMA %I TO %I', :'APP_SCHEMA', :'APP_RO_USER')\gexec
    SELECT format('GRANT SELECT ON ALL TABLES IN SCHEMA %I TO %I',
                  :'APP_SCHEMA', :'APP_RO_USER')\gexec
    SELECT format('GRANT SELECT ON ALL SEQUENCES IN SCHEMA %I TO %I',
                  :'APP_SCHEMA', :'APP_RO_USER')\gexec
    
    -- App: future objects default privileges
    SELECT format(
      'ALTER DEFAULT PRIVILEGES FOR ROLE %I IN SCHEMA %I GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO %I',
      :'APP_OWNER_USER', :'APP_SCHEMA', :'APP_USER'
    )\gexec
    SELECT format(
      'ALTER DEFAULT PRIVILEGES FOR ROLE %I IN SCHEMA %I GRANT SELECT ON TABLES TO %I',
      :'APP_OWNER_USER', :'APP_SCHEMA', :'APP_RO_USER'
    )\gexec
    SELECT format(
      'ALTER DEFAULT PRIVILEGES FOR ROLE %I IN SCHEMA %I GRANT USAGE, SELECT ON SEQUENCES TO %I',
      :'APP_OWNER_USER', :'APP_SCHEMA', :'APP_USER'
    )\gexec
    SELECT format(
      'ALTER DEFAULT PRIVILEGES FOR ROLE %I IN SCHEMA %I GRANT SELECT ON SEQUENCES TO %I',
      :'APP_OWNER_USER', :'APP_SCHEMA', :'APP_RO_USER'
    )\gexec
    
    \echo === App DB/roles initialized (3-role pattern) ===
    
    
    \echo === Creating Temporal roles and databases ===
    
    -- Temporal: NOLOGIN owner
    SELECT format('CREATE ROLE %I NOLOGIN', :'TEMPORAL_OWNER_USER')
    WHERE NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = :'TEMPORAL_OWNER_USER')\gexec
    
    -- Temporal: runtime/migration user (LOGIN)
    SELECT format('CREATE ROLE %I LOGIN PASSWORD %L', :'TEMPORAL_USER', :'TEMPORAL_USER_PASSWORD')
    WHERE NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = :'TEMPORAL_USER')\gexec
    
    -- Temporal: databases (owned by NOLOGIN owner)
    SELECT format('CREATE DATABASE %I OWNER %I', :'TEMPORAL_DB', :'TEMPORAL_OWNER_USER')
    WHERE NOT EXISTS (SELECT 1 FROM pg_database WHERE datname = :'TEMPORAL_DB')\gexec
    
    SELECT format('CREATE DATABASE %I OWNER %I', :'TEMPORAL_VIS_DB', :'TEMPORAL_OWNER_USER')
    WHERE NOT EXISTS (SELECT 1 FROM pg_database WHERE datname = :'TEMPORAL_VIS_DB')\gexec
    
    
    -- ===== Configure DB: temporal =====
    \connect :TEMPORAL_DB
    
    CREATE EXTENSION IF NOT EXISTS btree_gin;
    
    -- Lock down database and schema defaults
    SELECT format('REVOKE CREATE ON DATABASE %I FROM PUBLIC', :'TEMPORAL_DB')\gexec
    
    -- Allow Temporal to run migrations (CREATE) and operate (USAGE) in public schema
    SELECT format('GRANT USAGE, CREATE ON SCHEMA public TO %I', :'TEMPORAL_USER')\gexec
    
    -- Default privileges for future objects owned by NOLOGIN owner
    SELECT format(
      'ALTER DEFAULT PRIVILEGES FOR ROLE %I IN SCHEMA public
         GRANT SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER ON TABLES TO %I',
      :'TEMPORAL_OWNER_USER', :'TEMPORAL_USER'
    )\gexec
    SELECT format(
      'ALTER DEFAULT PRIVILEGES FOR ROLE %I IN SCHEMA public
         GRANT USAGE, SELECT, UPDATE ON SEQUENCES TO %I',
      :'TEMPORAL_OWNER_USER', :'TEMPORAL_USER'
    )\gexec
    
    -- Align privileges for any existing objects
    SELECT format(
      'GRANT SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER ON ALL TABLES IN SCHEMA public TO %I',
      :'TEMPORAL_USER'
    )\gexec
    SELECT format(
      'GRANT USAGE, SELECT, UPDATE ON ALL SEQUENCES IN SCHEMA public TO %I',
      :'TEMPORAL_USER'
    )\gexec
    
    
    -- ===== Configure DB: temporal_visibility =====
    \connect :TEMPORAL_VIS_DB
    
    CREATE EXTENSION IF NOT EXISTS btree_gin;
    
    SELECT format('REVOKE CREATE ON DATABASE %I FROM PUBLIC', :'TEMPORAL_VIS_DB')\gexec
    SELECT format('GRANT USAGE, CREATE ON SCHEMA public TO %I', :'TEMPORAL_USER')\gexec
    
    SELECT format(
      'ALTER DEFAULT PRIVILEGES FOR ROLE %I IN SCHEMA public
         GRANT SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER ON TABLES TO %I',
      :'TEMPORAL_OWNER_USER', :'TEMPORAL_USER'
    )\gexec
    SELECT format(
      'ALTER DEFAULT PRIVILEGES FOR ROLE %I IN SCHEMA public
         GRANT USAGE, SELECT, UPDATE ON SEQUENCES TO %I',
      :'TEMPORAL_OWNER_USER', :'TEMPORAL_USER'
    )\gexec
    
    SELECT format(
      'GRANT SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER ON ALL TABLES IN SCHEMA public TO %I',
      :'TEMPORAL_USER'
    )\gexec
    SELECT format(
      'GRANT USAGE, SELECT, UPDATE ON ALL SEQUENCES IN SCHEMA public TO %I',
      :'TEMPORAL_USER'
    )\gexec
    
    \echo === Temporal roles/databases created ===
    
    PSQL
    
    echo "==> Init completed"
