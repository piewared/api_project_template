apiVersion: v1
data:
  verify-init.sh: "#!/usr/bin/env sh\nset -eu\n\n# --- Inputs (prefer your PRODUCTION_* names if present) ------------------------\nAPP_DB=\"${APP_DB:-${APP_DB:-appdb}}\"\nAPP_USER=\"${APP_DB_USER:-${APP_DB_USER:-appuser}}\"\nAPP_RO=\"${APP_DB_RO_USER:-${APP_DB_RO_USER:-appreadonly}}\"\nAPP_OWNER=\"${APP_DB_OWNER:-${APP_DB_OWNER:-owner}}\"\nTEMPORAL_DB=\"${TEMPORAL_DB:-${TEMPORAL_DB:-temporal}}\"\nTEMPORAL_DB_USER=\"${TEMPORAL_DB_USER:-${TEMPORAL_DB_USER:-temporaluser}}\"\nTEMPORAL_DB_OWNER=\"${TEMPORAL_DB_OWNER:-${TEMPORAL_DB_USER}_owner}\"\nAPP_SCHEMA=\"${APP_SCHEMA:-app}\"\n\n# Comma-separated list of subnets that SHOULD be allowed via hostssl\n# e.g. \"172.30.50.0/24,10.10.0.0/16\"\nALLOWED_SUBNETS=\"${ALLOWED_SUBNETS:-172.30.50.0/24}\"\n\n# Optional: where certs live inside Postgres (match your Postgres config/volume)\n# If verifier has this path mounted read-only, we can check permissions.\nCERT_DIR=\"${CERT_DIR:-/etc/postgresql/ssl}\"\nCERT_FILE=\"${CERT_FILE:-server.crt}\"\nKEY_FILE=\"${KEY_FILE:-server.key}\"\n\n# --- psql (connect as app_user; PGPASSWORD is provided from Docker secret) -----\nPSQL=\"psql -U ${APP_USER} -w -At -h postgres -d postgres\"\nPSQL_APP=\"psql -U ${APP_USER} -w -At -h postgres -d ${APP_DB}\"\n\nok()  { printf \"✅ %s\\n\" \"$*\"; }\nbad() { printf \"❌ %s\\n\" \"$*\"; exit 1; }\nwarn(){ printf \"⚠️  %s\\n\" \"$*\"; }\n\necho \"== Verifying Postgres (host: postgres) ==\"\necho \"   DB=$APP_DB  OWNER=$APP_OWNER  USER=$APP_USER  RO=$APP_RO  SCHEMA=$APP_SCHEMA\"\necho \"   Temporal DB=$TEMPORAL_DB  USER=$TEMPORAL_DB_USER  OWNER=$TEMPORAL_DB_OWNER\"\necho\n\n# --- Core: roles / db / schema / grants ---------------------------------------\n\n# App DB roles exist?\n[ \"$($PSQL -c \"SELECT COUNT(*) FROM pg_roles WHERE rolname='${APP_USER}';\")\" = \"1\" ] \\\n  || bad \"Role ${APP_USER} does not exist\"\n[ \"$($PSQL -c \"SELECT COUNT(*) FROM pg_roles WHERE rolname='${APP_RO}';\")\" = \"1\" ] \\\n  || bad \"Role ${APP_RO} does not exist\"\n[ \"$($PSQL -c \"SELECT COUNT(*) FROM pg_roles WHERE rolname='${APP_OWNER}';\")\" = \"1\" ] \\\n  || bad \"Role ${APP_OWNER} does not exist\"\n\n# LOGIN/NOLOGIN checks\n[ \"$($PSQL -c \"SELECT rolcanlogin FROM pg_roles WHERE rolname='${APP_USER}';\")\" = \"t\" ] \\\n  || bad \"Role ${APP_USER} missing LOGIN\"\n[ \"$($PSQL -c \"SELECT rolcanlogin FROM pg_roles WHERE rolname='${APP_RO}';\")\" = \"t\" ] \\\n  || bad \"Role ${APP_RO} missing LOGIN\"\n[ \"$($PSQL -c \"SELECT rolcanlogin FROM pg_roles WHERE rolname='${APP_OWNER}';\")\" = \"f\" ] \\\n  || bad \"Role ${APP_OWNER} should be NOLOGIN\"\nok \"App DB role login attributes look correct (${APP_USER}/${APP_RO} LOGIN, ${APP_OWNER} NOLOGIN)\"\n\n# Temporal DB roles exist?\n\n[ \"$($PSQL -c \"SELECT COUNT(*) FROM pg_roles WHERE rolname='${TEMPORAL_DB_USER}';\")\" = \"1\" ] \\\n  || bad \"Role ${TEMPORAL_DB_USER} does not exist\"\n[ \"$($PSQL -c \"SELECT COUNT(*) FROM pg_roles WHERE rolname='${TEMPORAL_DB_OWNER}';\")\" = \"1\" ] \\\n  || bad \"Role ${TEMPORAL_DB_OWNER} does not exist\"\n\n# LOGIN/NOLOGIN checks\n[ \"$($PSQL -c \"SELECT rolcanlogin FROM pg_roles WHERE rolname='${TEMPORAL_DB_USER}';\")\" = \"t\" ] \\\n  || bad \"Role ${TEMPORAL_DB_USER} missing LOGIN\"\n[ \"$($PSQL -c \"SELECT rolcanlogin FROM pg_roles WHERE rolname='${TEMPORAL_DB_OWNER}';\")\" = \"f\" ] \\\n  || bad \"Role ${TEMPORAL_DB_OWNER} should be NOLOGIN\"\n\nok \"Temporal DB role login attributes look correct (${TEMPORAL_DB_USER} LOGIN, ${TEMPORAL_DB_OWNER} NOLOGIN)\"\n\n# Database ownership\nOWNER=\"$($PSQL -c \"SELECT pg_get_userbyid(datdba) FROM pg_database WHERE datname='${APP_DB}';\")\"\n[ -n \"$OWNER\" ] || bad \"Database ${APP_DB} does not exist\"\n[ \"$OWNER\" = \"$APP_OWNER\" ] || bad \"Database ${APP_DB} owner is '${OWNER}' (expected ${APP_OWNER})\"\nok \"Database ${APP_DB} owner is ${APP_OWNER}\"\n\n# Schema ownership\nSCHEMA_OWNER=\"$($PSQL_APP -c \"SELECT r.rolname\n                               FROM pg_namespace n\n                               JOIN pg_roles r ON r.oid = n.nspowner\n                               WHERE n.nspname='${APP_SCHEMA}';\")\"\n[ -n \"$SCHEMA_OWNER\" ] || bad \"Schema ${APP_SCHEMA} does not exist in ${APP_DB}\"\n[ \"$SCHEMA_OWNER\" = \"$APP_OWNER\" ] || bad \"Schema ${APP_SCHEMA} owner is '${SCHEMA_OWNER}' (expected ${APP_OWNER})\"\nok \"Schema ${APP_SCHEMA} owner is ${APP_OWNER}\"\n\n# Schema privileges (runtime)\n[ \"$($PSQL_APP -c \"SELECT has_schema_privilege('${APP_USER}','${APP_SCHEMA}','USAGE');\")\" = \"t\" ] \\\n  || bad \"${APP_USER} missing USAGE on ${APP_SCHEMA}\"\n[ \"$($PSQL_APP -c \"SELECT has_schema_privilege('${APP_RO}','${APP_SCHEMA}','USAGE');\")\" = \"t\" ] \\\n  || bad \"${APP_RO} missing USAGE on ${APP_SCHEMA}\"\nok \"Schema privileges (USAGE) look good\"\n\n# App user: DML on all tables\nMISSING_TBLS_RW=\"$($PSQL_APP -c \"\nWITH t AS (\n  SELECT quote_ident(n.nspname)||'.'||quote_ident(c.relname) AS fq\n  FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE n.nspname='${APP_SCHEMA}' AND c.relkind IN ('r','p')\n),\nmissing AS (\n  SELECT fq FROM t\n  WHERE NOT has_table_privilege('${APP_USER}', fq, 'SELECT')\n     OR NOT has_table_privilege('${APP_USER}', fq, 'INSERT')\n     OR NOT has_table_privilege('${APP_USER}', fq, 'UPDATE')\n     OR NOT has_table_privilege('${APP_USER}', fq, 'DELETE')\n)\nSELECT COALESCE(string_agg(fq, ', '), '') FROM missing;\n\")\"\n[ -z \"$MISSING_TBLS_RW\" ] && ok \"${APP_USER} has DML on all tables in ${APP_SCHEMA}\" \\\n                          || bad \"${APP_USER} missing DML on: ${MISSING_TBLS_RW}\"\n\n# App user: sequences\nMISSING_SEQS_RW=\"$($PSQL_APP -c \"\nWITH seqs AS (\n  SELECT quote_ident(n.nspname)||'.'||quote_ident(c.relname) AS fq\n  FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE n.nspname='${APP_SCHEMA}' AND c.relkind='S'\n),\nmissing AS (\n  SELECT fq FROM seqs\n  WHERE NOT has_sequence_privilege('${APP_USER}', fq, 'USAGE')\n     OR NOT has_sequence_privilege('${APP_USER}', fq, 'SELECT')\n)\nSELECT COALESCE(string_agg(fq, ', '), '') FROM missing;\n\")\"\n[ -z \"$MISSING_SEQS_RW\" ] && ok \"${APP_USER} has USAGE,SELECT on all sequences in ${APP_SCHEMA}\" \\\n                          || bad \"${APP_USER} missing sequence privileges on: ${MISSING_SEQS_RW}\"\n\n# Read-only user: tables\nMISSING_TBLS_RO=\"$($PSQL_APP -c \"\nWITH t AS (\n  SELECT quote_ident(n.nspname)||'.'||quote_ident(c.relname) AS fq\n  FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE n.nspname='${APP_SCHEMA}' AND c.relkind IN ('r','p')\n),\nmissing AS (\n  SELECT fq FROM t\n  WHERE NOT has_table_privilege('${APP_RO}', fq, 'SELECT')\n)\nSELECT COALESCE(string_agg(fq, ', '), '') FROM missing;\n\")\"\n[ -z \"$MISSING_TBLS_RO\" ] && ok \"${APP_RO} has SELECT on all tables in ${APP_SCHEMA}\" \\\n                          || bad \"${APP_RO} missing SELECT on: ${MISSING_TBLS_RO}\"\n\n# Read-only user: sequences (optional but useful for dumps/BI)\nMISSING_SEQS_RO=\"$($PSQL_APP -c \"\nWITH seqs AS (\n  SELECT quote_ident(n.nspname)||'.'||quote_ident(c.relname) AS fq\n  FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE n.nspname='${APP_SCHEMA}' AND c.relkind='S'\n),\nmissing AS (\n  SELECT fq FROM seqs\n  WHERE NOT has_sequence_privilege('${APP_RO}', fq, 'SELECT')\n)\nSELECT COALESCE(string_agg(fq, ', '), '') FROM missing;\n\")\"\n[ -z \"$MISSING_SEQS_RO\" ] && ok \"${APP_RO} has SELECT on all sequences in ${APP_SCHEMA}\" \\\n                          || warn \"${APP_RO} missing sequence SELECT on: ${MISSING_SEQS_RO}\"\n\n# --- OPTIONAL: verify default privileges from owner (best-effort) --------------\n# Check if aclexplode function is available (PostgreSQL 9.0+)\nHAS_ACLEXPLODE=\"$($PSQL_APP -c \"SELECT COUNT(*) > 0 FROM pg_proc WHERE proname = 'aclexplode';\")\"\nif [ \"$HAS_ACLEXPLODE\" = \"t\" ]; then\n  MISSING_DEF_TBL=\"$($PSQL_APP -c \"\n    WITH d AS (\n      SELECT d.defaclobjtype, d.defaclacl\n      FROM pg_default_acl d\n      JOIN pg_namespace n ON n.oid = d.defaclnamespace\n      JOIN pg_roles r ON r.oid = d.defaclrole\n      WHERE n.nspname='${APP_SCHEMA}' AND r.rolname='${APP_OWNER}' AND d.defaclobjtype='r'\n    ),\n    e AS (\n      SELECT (aclexplode(defaclacl)).grantee AS grantee, (aclexplode(defaclacl)).privilege_type AS priv\n      FROM d\n    )\n    SELECT COUNT(*) FILTER (WHERE priv='SELECT' AND grantee = (SELECT oid FROM pg_roles WHERE rolname='${APP_USER}')) >= 1\n       AND COUNT(*) FILTER (WHERE priv='INSERT' AND grantee = (SELECT oid FROM pg_roles WHERE rolname='${APP_USER}')) >= 1\n       AND COUNT(*) FILTER (WHERE priv='UPDATE' AND grantee = (SELECT oid FROM pg_roles WHERE rolname='${APP_USER}')) >= 1\n       AND COUNT(*) FILTER (WHERE priv='DELETE' AND grantee = (SELECT oid FROM pg_roles WHERE rolname='${APP_USER}')) >= 1\n       AND COUNT(*) FILTER (WHERE priv='SELECT' AND grantee = (SELECT oid FROM pg_roles WHERE rolname='${APP_RO}')) >= 1\n    FROM e;\n  \")\"\n  [ \"$MISSING_DEF_TBL\" = \"t\" ] && ok \"Default privileges (tables) appear correctly set from owner\" \\\n                               || warn \"Default privileges (tables) may be missing/incomplete for ${APP_USER}/${APP_RO}\"\n\n  MISSING_DEF_SEQ=\"$($PSQL_APP -c \"\n    WITH d AS (\n      SELECT d.defaclobjtype, d.defaclacl\n      FROM pg_default_acl d\n      JOIN pg_namespace n ON n.oid = d.defaclnamespace\n      JOIN pg_roles r ON r.oid = d.defaclrole\n      WHERE n.nspname='${APP_SCHEMA}' AND r.rolname='${APP_OWNER}' AND d.defaclobjtype='S'\n    ),\n    e AS (\n      SELECT (aclexplode(defaclacl)).grantee AS grantee, (aclexplode(defaclacl)).privilege_type AS priv\n      FROM d\n    )\n    SELECT COUNT(*) FILTER (WHERE priv='USAGE' AND grantee = (SELECT oid FROM pg_roles WHERE rolname='${APP_USER}')) >= 1\n       AND COUNT(*) FILTER (WHERE priv='SELECT' AND grantee = (SELECT oid FROM pg_roles WHERE rolname='${APP_USER}')) >= 1\n       AND COUNT(*) FILTER (WHERE priv='SELECT' AND grantee = (SELECT oid FROM pg_roles WHERE rolname='${APP_RO}')) >= 1\n    FROM e;\n  \")\"\n  [ \"$MISSING_DEF_SEQ\" = \"t\" ] && ok \"Default privileges (sequences) appear correctly set from owner\" \\\n                               || warn \"Default privileges (sequences) may be missing/incomplete for ${APP_USER}/${APP_RO}\"\nelse\n  warn \"Cannot verify default privileges (no aclexplode()); skip or check manually in pg_default_acl\"\nfi\n\n# --- TLS: server-side settings & connection is actually SSL --------------------\nSSL_ON=\"$($PSQL -c \"SHOW ssl;\")\"\n[ \"$SSL_ON\" = \"on\" ] || bad \"ssl is OFF (SHOW ssl)\"\nok \"ssl=on\"\n\n# Our current session should be SSL (prove it via pg_stat_ssl)\nCURR_SSL=\"$($PSQL -c \"SELECT ssl FROM pg_stat_ssl WHERE pid = pg_backend_pid();\")\"\n[ \"$CURR_SSL\" = \"t\" ] && ok \"Current connection is using TLS\" \\\n                      || bad \"Current connection is NOT using TLS\"\n\n# Negative test: non-TLS must fail (sslmode=disable)\nif psql \"host=postgres dbname=${APP_DB} user=${APP_USER} password=${PGPASSWORD} sslmode=disable\" -At -c \"select 1\" >/dev/null 2>&1; then\n  bad \"Non-TLS connection (sslmode=disable) unexpectedly succeeded\"\nelse\n  ok \"Non-TLS connection (sslmode=disable) correctly rejected\"\nfi\n\n# --- pg_hba: prove TLS-only using parsed rules (pg_hba_file_rules) ------------\n# pg_hba_file_rules is superuser-only. We'll try as app_user first; on permission error, retry as superuser if provided.\n\nrun_hba_query() {\n  q=\"$1\"\n  # try as app user first\n  if out=\"$(PGPASSWORD=\"${PGPASSWORD}\" psql -U \"${APP_USER}\" -w -At -h postgres -d postgres -c \"$q\" 2>&1)\"; then\n    printf \"%s\" \"$out\"\n    return 0\n  fi\n  # fallback to superuser if permission denied and we have superuser credentials\n  if printf \"%s\" \"$out\" | grep -qi \"permission denied\" && [ -n \"${PGSU_PASSWORD:-}\" ]; then\n    if su_out=\"$(PGPASSWORD=\"${PGSU_PASSWORD}\" psql -U postgres -w -At -h postgres -d postgres -c \"$q\" 2>&1)\"; then\n      printf \"%s\" \"$su_out\"\n      return 0\n    else\n      printf \"%s\" \"$su_out\" >&2\n      return 1\n    fi\n  fi\n  printf \"%s\" \"$out\" >&2\n  return 1\n}\n\n# 1) hostnossl rejects for v4/v6\nHBA_V4_REJECT=\"$(run_hba_query \"\n  SELECT count(*) FROM pg_hba_file_rules\n  WHERE type='hostnossl' AND auth_method='reject' AND address='0.0.0.0' AND netmask='0.0.0.0';\n\")\" || bad \"pg_hba_file_rules not accessible and no superuser provided\"\n[ \"$HBA_V4_REJECT\" -ge 1 ] && ok \"pg_hba: hostnossl v4 reject present\" \\\n                           || warn \"pg_hba: hostnossl v4 reject not found\"\n\nHBA_V6_REJECT=\"$(run_hba_query \"\n  SELECT count(*) FROM pg_hba_file_rules\n  WHERE type='hostnossl' AND auth_method='reject' AND address='::' AND netmask='::';\n\")\"\n[ \"$HBA_V6_REJECT\" -ge 1 ] && ok \"pg_hba: hostnossl v6 reject present\" \\\n                           || warn \"pg_hba: hostnossl v6 reject not found\"\n\n# Helper function to convert CIDR to address/netmask for pg_hba_file_rules queries\ncidr_to_address_netmask() {\n  local cidr=\"$1\"\n  local ip=\"${cidr%/*}\"\n  local prefix=\"${cidr#*/}\"\n  \n  case \"$ip\" in\n    *:*) # IPv6\n      if [ \"$prefix\" = \"0\" ]; then\n        echo \"address='::' AND netmask='::'\"\n      else\n        # For simplicity, just match the network address\n        echo \"address='$ip'\"\n      fi\n      ;;\n    *) # IPv4\n      case \"$prefix\" in\n        0)  echo \"address='0.0.0.0' AND netmask='0.0.0.0'\" ;;\n        8)  echo \"address='${ip}' AND netmask='255.0.0.0'\" ;;\n        16) echo \"address='${ip}' AND netmask='255.255.0.0'\" ;;\n        24) echo \"address='${ip}' AND netmask='255.255.255.0'\" ;;\n        32) echo \"address='${ip}' AND netmask='255.255.255.255'\" ;;\n        *)  echo \"address='${ip}'\" ;; # fallback: just match address\n      esac\n      ;;\n  esac\n}\n\n# 2) For each allowed subnet, ensure there is a hostssl allow with scram-sha-256 or md5\nOLDIFS=\"$IFS\"\nIFS=','; for cidr in $ALLOWED_SUBNETS; do\n  cidr=\"$(echo \"$cidr\" | tr -d ' ')\"\n  [ -z \"$cidr\" ] && continue\n  \n  # Convert CIDR to address/netmask format\n  addr_mask=\"$(cidr_to_address_netmask \"$cidr\")\"\n  \n  HAS_ALLOW=\"$(run_hba_query \"\n    SELECT count(*) FROM pg_hba_file_rules\n    WHERE type='hostssl' AND ${addr_mask} AND auth_method IN ('scram-sha-256','md5');\n  \")\"\n  [ \"$HAS_ALLOW\" -ge 1 ] && ok \"pg_hba: hostssl allow present for ${cidr}\" \\\n                         || bad \"pg_hba: missing hostssl allow for ${cidr}\"\ndone\nIFS=\"$OLDIFS\"\n\n# 3) Broad non-TLS host rules\nHAS_BROAD_HOST=\"$(run_hba_query \"\n  SELECT count(*) FROM pg_hba_file_rules\n  WHERE type='host' AND \n        ((address='0.0.0.0' AND netmask='0.0.0.0') OR \n         (address='::' AND netmask='::') OR \n         address IS NULL)\n    AND auth_method IN ('scram-sha-256','md5');\n\")\"\n[ \"$HAS_BROAD_HOST\" -eq 0 ] && ok \"pg_hba: no broad non-TLS 'host' rules\" \\\n                             || warn \"pg_hba: found broad non-TLS 'host' rule (tighten to hostssl)\"\n\n# --- OPTIONAL: file-level cert checks (only if mounted) ------------------------\nif [ -f \"${CERT_DIR}/${CERT_FILE}\" ] && [ -f \"${CERT_DIR}/${KEY_FILE}\" ]; then\n  CRT_PERM=\"$(stat -c '%a' \"${CERT_DIR}/${CERT_FILE}\")\"\n  KEY_PERM=\"$(stat -c '%a' \"${CERT_DIR}/${KEY_FILE}\")\"\n  [ \"$CRT_PERM\" -le 644 ] && ok \"Cert perms OK (${CERT_FILE} ${CRT_PERM})\" \\\n                          || warn \"Cert perms loose (${CERT_FILE} ${CRT_PERM})\"\n  [ \"$KEY_PERM\" -le 600 ] && ok \"Key perms OK (${KEY_FILE} ${KEY_PERM})\" \\\n                          || bad \"Key perms must be 600 or stricter (${KEY_FILE} ${KEY_PERM})\"\nelse\n  warn \"Cert files not mounted in verifier; skipping permission checks (set CERT_DIR or mount volume)\"\nfi\n\nok \"All checks passed \U0001F389\"\n"
kind: ConfigMap
metadata:
  annotations:
    use-subpath: "true"
  labels:
    io.kompose.service: postgres-verifier
  name: postgres-verifier-cm0
