"""User repository for data access."""

from sqlmodel import Session, select

from .entity import User
from .table import UserTable


class UserRepository:
    """Data access layer for User entities.

    This handles all database operations for Users while keeping
    the data access logic colocated with the User entity.
    """

    def __init__(self, session: Session) -> None:
        self._session = session

    def get(self, user_id: str) -> User | None:
        """Get a user by ID."""
        row = self._session.get(UserTable, user_id)
        if row is None:
            return None
        return User.model_validate(row, from_attributes=True)

    def list(self, offset: int = 0, limit: int = 100) -> list[User]:
        """List users with pagination."""
        statement = select(UserTable).offset(offset).limit(limit)
        rows = self._session.exec(statement).all()
        return [User.model_validate(row, from_attributes=True) for row in rows]

    def create(self, user: User) -> User:
        """Create a new user and return it. ID is auto-generated by the entity."""
        row = UserTable.model_validate(user, from_attributes=True)
        self._session.add(row)
        return user  # No need for flush/refresh - entity already has its ID!

    def update(self, user: User) -> User:
        """Update an existing user."""
        row = self._session.get(UserTable, user.id)
        if row is None:
            raise ValueError(f"User with ID {user.id} not found")

        # Update the row with new values
        for field, value in user.model_dump().items():
            setattr(row, field, value)

        return user
